#!/usr/bin/python3

import re
import json
import time
import getpass
import pathlib
import urllib3
import argparse
import colorama
import requests
import urllib.parse

from typing import Callable

__version__ = '2.0.2'

BASE_URL = 'netauth.nankai.edu.cn'
BASE_PORT = 804
ROOT = f'https://{BASE_URL}:{BASE_PORT}/eportal/portal/'
TIMEOUT = 3


def connectivity_check(
        success: Callable,
        error: Callable,
        timeout: int = TIMEOUT,
        msg: str | None = None,
):
    try:
        requests.head('https://www.baidu.com/', timeout=timeout)
        if success is not None:
            return success(msg)
    except (requests.exceptions.ReadTimeout, requests.exceptions.ConnectionError):
        if error is not None:
            return error(msg)


def compute_key(key: str) -> int:
    computed_key = 0
    for char in key:
        computed_key ^= ord(char)
    return computed_key


def encode_string(string: str, key: str = 'drcom') -> str:
    if not string:
        return ''
    if len(string) > 512:
        return '-1'
    output = ''
    computed_key = compute_key(key)
    for char in string:
        ch = ord(char) ^ computed_key
        str_hex = format(ch, '02x')
        output += str_hex
    return output


def decode_string(encoded: str, key: str = 'drcom'):
    if not encoded:
        return ''
    if len(encoded) % 2 != 0:
        raise ValueError('Encoded string must have an even length.')
    decoded = ''
    computed_key = compute_key(key)
    for i in range(0, len(encoded), 2):
        hex_pair = encoded[i:i + 2]
        ch = int(hex_pair, 16)
        original_ch = ch ^ computed_key
        decoded += chr(original_ch)
    return decoded


def print_status():
    response = requests.get(f'https://{BASE_URL}')
    try:
        username = re.findall(r'uid=\'(.*?)\'', response.text)[0]
    except IndexError:
        username = 'N/A'
    print(f'Login account: {username}')


def login(args_: argparse.Namespace):
    def on_success(_):
        print('Login successful')
        print_status()

    def on_error(msg: str):
        print(f'Login failed: {msg}')

    if connectivity_check(success=lambda _: True, error=lambda _: False):
        print('The campus network is already authenticated.')
        if input('Do you want to login again? [y/n]? ').lower() != 'y':
            print('Exiting...')
            return

    if args_.config is not None:
        config_path = pathlib.Path(args_.config)
    else:
        config_path = pathlib.Path.home() / '.config' / 'nknet' / 'config.json'
    if config_path.exists() and args_.auto_login:
        config = json.loads(config_path.read_text())
        username = config['username']
        password = config['password']
    else:
        username = input('username: ')
        password = getpass.getpass('password: ')
    print('Logging in...')
    response = requests.get(
        urllib.parse.urljoin(ROOT, 'login'),
        params={
            'callback': encode_string('dr1001'),
            'user_account': encode_string(f',`,{username}'),
            'user_password': encode_string(password),
        },
    )
    time.sleep(3)
    connectivity_check(success=on_success, error=on_error, msg=response.text)
    if not args_.no_save:
        config_path.parent.mkdir(parents=True, exist_ok=True)
        config_path.write_text(json.dumps({'username': username, 'password': password}))


def logout(_):
    def on_success(_):
        print('Logout successful')

    def on_error(msg: str):
        print(f'Logout failed: {msg}')

    print('Logging out...')
    response = requests.get(urllib.parse.urljoin(ROOT, 'logout'))
    time.sleep(3)
    connectivity_check(success=on_error, error=on_success, msg=response.text)


def status(args_: argparse.Namespace):
    def on_success(_):
        print(f'Status: {colorama.Fore.LIGHTGREEN_EX}online{colorama.Fore.RESET}')
        print_status()

    def on_error(_):
        print(f'Status: {colorama.Fore.LIGHTRED_EX}offline{colorama.Fore.RESET}')

    print('Detecting network status...')
    connectivity_check(success=on_success, error=on_error)


if __name__ == '__main__':
    colorama.init()
    urllib3.util.connection.HAS_IPV6 = False
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
    parser = argparse.ArgumentParser(
        description='manage login/logout and check the status of the campus network',
    )
    parser.set_defaults(func=lambda _: parser.print_help())
    parser.add_argument('-v', '--version', action='version', version=__version__)
    subparsers = parser.add_subparsers(dest='command', title='commands')

    login_parser = subparsers.add_parser('login', help='login to the campus network')
    login_parser.add_argument('-c', '--config', required=False, type=str,
                              help='path to the config file containing login details')
    login_parser.add_argument('-a', '--auto-login', required=False, action='store_true',
                              help='automatically login using the credentials from the config file (if available)')
    login_parser.add_argument('-n', '--no-save', required=False, action='store_true',
                              help='do not save the username and password to the config file')
    login_parser.set_defaults(func=login)

    logout_parser = subparsers.add_parser('logout', help='logout from the campus network')
    logout_parser.set_defaults(func=logout)

    status_parser = subparsers.add_parser('status', help='check the status of the campus network')
    status_parser.set_defaults(func=status)

    args = parser.parse_args()
    args.func(args)
